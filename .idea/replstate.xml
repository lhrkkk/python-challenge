<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1443280402618">{:repl-history {:ide [], :local [&quot;(shred-user)&quot; &quot;(def s 1\n  \n  )&quot; &quot;(println \&quot;hell\&quot;)&quot; &quot;(= (complement some?) contains?)&quot; &quot;(= (complement some?) nil?)&quot; &quot;(= (complement some?) empty?)&quot; &quot;(= (complement some?) (or nil? empty?))&quot; &quot;(= (complement some?) (fn [] (or nil? empty?)))&quot; &quot;(require '[clojure.java.io :as io])&quot; &quot;(defn shred-user []\n  (map #(ns-unmap *ns* %)\n       (filter (complement #{'shred-user}) (keys (ns-interns *ns*)))\n       ))&quot; &quot;(with-open [r (io/reader \&quot;case\&quot;)]\n  (doseq [liene (line-seq r)]\n    (println line)))&quot; &quot;(with-open [r (io/reader \&quot;case\&quot;)]\n  (doseq [line (line-seq r)]\n    (println line)))&quot; &quot;(println root-directory)&quot; &quot;(root-directory)&quot; &quot;#\&quot;/w\&quot;&quot; &quot;(with-open [r (io/reader \&quot;case\&quot;)]\n  (doseq [line (line-seq r)]\n    (re-matcher #\&quot;/w\&quot; line)))&quot; &quot;(with-open [r (io/reader \&quot;case\&quot;)]\n  (doseq [line (line-seq r)]\n    (println (re-matcher #\&quot;/w\&quot; line))))&quot; &quot;re-match&quot; &quot;(with-open [r (io/reader \&quot;case\&quot;)]\n  (doseq [line (line-seq r)]\n    (println (re-match #\&quot;/w\&quot; line))))&quot; &quot;(with-open [r (io/reader \&quot;case\&quot;)]\n  (doseq [line (line-seq r)]\n    (println (re-matches #\&quot;/w\&quot; line))))&quot; &quot;(with-open [r (io/reader \&quot;case\&quot;)]\n  (doseq [line (line-seq r)]\n    (println (re-find #\&quot;/w\&quot; line))))&quot; &quot;(with-open [r (io/reader \&quot;case\&quot;)]\n  (doseq [line (line-seq r)]\n    (println (re-find #\&quot;(/w)\&quot; line))))&quot; &quot;(with-open [r (io/reader \&quot;case\&quot;)]\n  (doseq [line (line-seq r)]\n    ((if-let [s (re-find #\&quot;(/w)\&quot; line)]\n       (println s)\n       ))))&quot; &quot;(with-open [r (io/reader \&quot;case\&quot;)]\n  (doseq [line (line-seq r)]\n    ((if-let [[s] (re-find #\&quot;(/w)\&quot; line)]\n       (println s)\n       ))))&quot; &quot;(with-open [r (io/reader \&quot;case\&quot;)]\n  (doseq [line (line-seq r)]\n    (if-let [[s] (re-find #\&quot;(/w)\&quot; line)]\n      (println s)\n      )))&quot; &quot;(with-open [r (io/reader \&quot;case\&quot;)]\n  (doseq [line (line-seq r)]\n    (if-let [[s] (re-find #\&quot;(\\w)\&quot; line)]\n      (println s)\n      )))&quot; &quot;(with-open [r (io/reader \&quot;case\&quot;)]\n  (doseq [line (line-seq r)]\n    (if-let [[s] (re-find #\&quot;([a-z])\&quot; line)]\n      (println s)\n      )))&quot; &quot;(with-open [r (io/reader \&quot;case\&quot;)]\n  (for [line (line-seq r)]\n    (if-let [[s] (re-find #\&quot;([a-z])\&quot; line)]\n      s\n      )))&quot; &quot;(with-open [r (io/reader \&quot;case\&quot;)]\n  (doseq [line (line-seq r)]\n    (if-let [[s] (re-find #\&quot;([a-z])\&quot; line)]\n      s\n      )))&quot; &quot;(with-open [r (io/reader \&quot;case\&quot;)]\n  (doseq [line (line-seq r)]\n    (if-let [[s] (re-find #\&quot;([a-z])\&quot; line)]\n      (swap! cumm str s)\n      )))&quot; &quot;(def cumms (atom \&quot;\&quot;))&quot; &quot;(with-open [r (io/reader \&quot;case\&quot;)]\n  (doseq [line (line-seq r)]\n    (if-let [[s] (re-find #\&quot;([a-z])\&quot; line)]\n      (swap! cumms str s)\n      )))&quot; &quot;(println cumms)&quot; &quot;(println (str cumms))&quot; &quot;(require '[clojure.string :as str] )\n&quot; &quot;(str/join [1 2 3])&quot; &quot;(def a [ \\a \\b \\c \\d])&quot; &quot;(into []\n      (for [i a] i))&quot; &quot;(into \&quot;\&quot; \n      (for [i a] i))&quot; &quot;(into [] \n      (for [i a] i))&quot; &quot;(for [i a ]i)&quot; &quot;(into str\n      (for [i a] i))&quot; &quot;(into #(str %)\n      (for [i a] i))&quot; &quot;(reduce #(str %)\n      (for [i a] i))&quot; &quot;(reduce #(str %) \n      i)&quot; &quot;(reduce #(str %) \n      a)&quot; &quot;(reduce #(str %) a)&quot; &quot;(str \\q)&quot; &quot;(reduce #(str % %) a)&quot; &quot;(reduce #(str %1 %2) a)&quot; &quot;(defn to-str [a] (reduce #(str %1 %2) a))&quot; &quot;(vec-to-str a)&quot; &quot;(defn maketrans [origin-table trans-table] (zipmap origin-table trans-table))&quot; &quot;(load \&quot;src/python_challenge/util.clj\&quot;)&quot; &quot;(ns python-challenge.pc2\n  (:require [python-challenge.util :as new]))&quot; &quot;(ns python-challenge.util)&quot; &quot;(defn vec-to-str [a] (reduce #(str %1 %2) a))&quot; &quot;(defn ns-clean\n  \&quot;Remove all internal mappings from a given name space or the current one if no parameter given.\&quot;\n  ([] (ns-clean *ns*))\n  ([ns] (map #(ns-unmap ns %) (keys (ns-interns ns)))))&quot; &quot;(defn ns-clean []\n  ([] (ns-clean *ns*))\n  ([ns] (map #(ns-unmap ns %)\n        (filter (complement #{'ns-clean}) (keys (ns-interns ns)))\n        )))&quot; &quot;(defn ns-clean \n  ([] (ns-clean *ns*))\n  ([ns] (map #(ns-unmap ns %)\n        (filter (complement #{'ns-clean}) (keys (ns-interns ns)))\n        )))&quot; &quot;(python-challenge.util/ns-clean)&quot; &quot;(python-challenge.util/ns-clean)\n&quot; &quot;@cumms&quot; &quot;(def s 1)&quot; &quot;(ns-clean)\n&quot; &quot;s&quot; &quot;(ns-clean *ns*)&quot; &quot;(ns-clean 'python-challenge.pc2)&quot; &quot;(def ss 1)&quot; &quot;ss&quot; &quot;ns-clean&quot; &quot;cumms&quot; &quot;(println @cumms)&quot; &quot;(def a (vec (range 1 (inc 10))))&quot; &quot;(subvec a 3)&quot; &quot;(subvec a 0 (- (count a) 3))&quot; &quot;(subvec a (- (count a) 3))&quot; &quot;(subvec a 3 (+ 3 4))&quot; &quot;(subvec a 0 3)&quot; &quot;(-&gt;&gt; a  (drop 3) (take 8))&quot; &quot;(-&gt;&gt; a  (drop 3) (take 3))&quot; &quot;(subvec a 3 (- (count a) 3))&quot; &quot;`a&quot; &quot;(ns python-challenge.pc3\n  (:require [python-challenge.util :only ns-clean]))&quot; &quot;(ns-clean)&quot; &quot;a&quot; &quot;(require 'clojure.string)&quot; &quot;(refer 'clojure.string\n       :rename '{capitalize cap, trim trm}\n       :only '[cap trm])&quot; &quot;(refer 'clojure.string\n       )&quot; &quot;(use 'clojure.string)&quot; &quot;(ns python-challenge.learn-notes\n  (:require [python-challenge.util :only ns-clean]))&quot;], :remote []}}</component>
</project>